<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Installment Breakdown</title>

  <!-- Firebase (v9 compat) -->
  <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-database-compat.js"></script>

  <!-- Tailwind for quick styling -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"/>

  <style>
    .status-pill { padding:2px 8px; border-radius:999px; font-size: 11px; font-weight:600; }
    .status-cleared { background:#dcfce7; color:#166534; }
    .status-partial { background:#fef9c3; color:#854d0e; }
    .status-overdue { background:#fee2e2; color:#991b1b; }
    .table-header { background:#eef2ff; color:#1f2937; }
  </style>
</head>
<body class="bg-white">
  <div id="breakdownContent" class="text-sm p-4">
    <!-- skeleton loader -->
    <div id="skel" class="animate-pulse">
      <div class="h-4 bg-slate-200 rounded w-2/3 mb-3"></div>
      <div class="h-3 bg-slate-200 rounded w-full mb-2"></div>
      <div class="h-3 bg-slate-200 rounded w-5/6"></div>
    </div>
  </div>

  <script>
    (function () {
      const SOMAP_DEFAULT_YEAR = 2025;
      const CLASS_ORDER = ['Baby Class','Class 1','Class 2','Class 3','Class 4','Class 5','Class 6','Class 7'];
      const norm = (s) => String(s || '').trim().toLowerCase();
      function shiftClass(baseName, deltaYears) {
        const i = CLASS_ORDER.findIndex((c) => norm(c) === norm(baseName));
        if (i < 0) return baseName || '';
        const j = i + Number(deltaYears || 0);
        if (j < 0) return 'PRE-ADMISSION';
        if (j >= CLASS_ORDER.length) return 'GRADUATED';
        return CLASS_ORDER[j];
      }

      // ---- Parent scope detection ----
      const q = new URL(location.href).searchParams;
      const isParentScope = (q.get('scope')||'').toLowerCase() === 'parent';
      const targetYearNum = Number(q.get('year') || SOMAP_DEFAULT_YEAR);
      const targetYear = Number.isFinite(targetYearNum) ? targetYearNum : SOMAP_DEFAULT_YEAR;
      const targetYearStr = String(targetYear);

      // ---- Firebase init (inline, so the iframe never depends on ../firebase.js) ----
      const firebaseConfig = {
        apiKey: "AIzaSyBhONntRE_aRsU0y1YcPZzWud3CBfwH_a8",
        authDomain: "somaptestt.firebaseapp.com",
        databaseURL: "https://somaptestt-default-rtdb.firebaseio.com",
        projectId: "somaptestt",
        storageBucket: "somaptestt.appspot.com",
        messagingSenderId: "105526245138",
        appId: "1:105526245138:web:b8e7c0cb82a46e861965cb",
        measurementId: "G-4HKX7KN6Q3"
      };
      try { if (!firebase?.apps?.length) firebase.initializeApp(firebaseConfig); }
      catch (e) { console.error('Firebase init error', e); }
      const db = (() => { try { return firebase.database(); } catch { return null; }})();

      const mount = (html) => {
        const el = document.getElementById('breakdownContent');
        el.innerHTML = html;
        // ask parent to resize this iframe
        const h = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
        try { window.parent.postMessage({ type:'resizeIframe', id: window.__STUDENT_ID__, height: h }, '*'); } catch {}
      };
      const err = (msg) => mount(`<div class="p-3 rounded bg-rose-50 text-rose-700 border border-rose-200">${msg}</div>`);

      if (!db) { err('Error: Database not initialized. Please check Firebase credentials or internet connection.'); return; }

      // ---- helpers ----
      const fmt = (n) => (Number(n) || 0).toLocaleString();
      const nowTS = () => Date.now();
      function ymdToTS(academicYear, m, d, endOfDay = false) {
        const y = (m === 12) ? (Number(academicYear) - 1) : Number(academicYear);
        return endOfDay
          ? new Date(y, m - 1, d, 23, 59, 59, 999).getTime()
          : new Date(y, m - 1, d, 0, 0, 0, 0).getTime();
      }
      function apportion(total, weights) {
        if (!Array.isArray(weights) || !weights.length) return [];
        const sumW = weights.reduce((a, b) => a + b, 0);
        let amounts = weights.map(w => Math.floor((w * total) / sumW));
        let sumA = amounts.reduce((a, b) => a + b, 0);
        let rem = total - sumA;
        if (rem > 0) {
          const sortedIdx = [...weights.keys()].sort((a, b) => weights[b] - weights[a]);
          for (let i = 0; i < rem; i++) amounts[sortedIdx[i % sortedIdx.length]]++;
        }
        return amounts;
      }

      function coercePaymentMap(raw) {
        if (!raw) return {};
        if (Array.isArray(raw)) {
          return raw.reduce((acc, entry, idx) => {
            if (entry != null) acc[`idx-${idx}`] = entry;
            return acc;
          }, {});
        }
        if (typeof raw === 'object') return { ...raw };
        return {};
      }

      function extractPaymentsMap(raw, targetYear) {
        if (!raw || typeof raw !== 'object') return {};
        const yearKey = String(targetYear);
        const numericYear = Number(targetYear);

        if (raw.payments || raw.entries || raw.records) {
          return coercePaymentMap(raw.payments || raw.entries || raw.records);
        }

        const possibleBucket =
          raw[yearKey] ??
          raw[String(numericYear)] ??
          raw[numericYear];
        if (possibleBucket && typeof possibleBucket === 'object') {
          if (possibleBucket.payments || possibleBucket.entries || possibleBucket.records) {
            return coercePaymentMap(possibleBucket.payments || possibleBucket.entries || possibleBucket.records);
          }
          return coercePaymentMap(possibleBucket);
        }

        return coercePaymentMap(raw);
      }

      function normalizeLedgerPayments(source, targetYear) {
        const normalized = {};
        if (!source) return normalized;
        const desiredYear = Number(targetYear);
        Object.entries(source).forEach(([key, raw]) => {
          if (!raw) return;
          const amount = Number(raw.amount ?? raw.value ?? raw.paid ?? raw.payment ?? raw.total ?? 0);
          if (!Number.isFinite(amount) || amount <= 0) return;
          const timestamp = Number(
            raw.timestamp ?? raw.datePaid ?? raw.createdAt ?? raw.recordedAt ?? raw.updatedAt ?? raw.time ?? Date.now()
          );
          let paymentYear = Number(
            raw.academicYear ??
            raw.financeYear ??
            raw.feeYear ??
            raw.year ??
            raw._year ??
            raw.academic_session
          );
          if (!Number.isFinite(paymentYear) && Number.isFinite(timestamp)) {
            const ts = new Date(timestamp);
            if (!Number.isNaN(ts.getTime())) paymentYear = ts.getFullYear();
          }
          if (Number.isFinite(desiredYear) && Number.isFinite(paymentYear) && paymentYear !== desiredYear) return;
          const payload = { ...raw, amount: Math.round(Math.max(0, amount)), timestamp };
          if (Number.isFinite(paymentYear)) payload.academicYear = paymentYear;
          else if (Number.isFinite(desiredYear)) payload.academicYear = desiredYear;
          normalized[key] = payload;
        });
        return normalized;
      }

      // ---- installment configs (DISCOUNTS REMOVED) ----
      const installmentConfigs = {
        lower: {
          type: '6', weights: [44, 13, 12, 22, 22, 16],
          labels: ['Inst 1','Inst 2','Inst 3','Inst 4','Inst 5','Inst 6'],
          windows: [
            { from:[12,1], to:[1,10] }, { from:[3,1], to:[3,15] }, { from:[4,1], to:[4,15] },
            { from:[5,1], to:[5,15] }, { from:[7,1], to:[7,15] }, { from:[9,1], to:[9,15] },
          ]
        },
        class4_7: {
          type: '4', weights: [328, 180, 176, 132],
          labels: ['Inst 1','Inst 2','Inst 3','Inst 4'],
          windows: [
            { from:[12,1], to:[1,10] }, { from:[3,1], to:[3,15] }, { from:[4,1], to:[4,15] }, { from:[5,1], to:[5,15] }
          ]
        },
        class5: {
          type: '6', weights: [44, 23, 22, 32, 26, 17],
          labels: ['Inst 1','Inst 2','Inst 3','Inst 4','Inst 5','Inst 6'],
          windows: [
            { from:[12,1], to:[1,10] }, { from:[3,1], to:[3,15] }, { from:[4,1], to:[4,15] },
            { from:[5,1], to:[5,15] }, { from:[7,1], to:[7,15] }, { from:[9,1], to:[9,15] },
          ]
        },
        class6: {
          type: '6', weights: [236, 115, 110, 160, 160, 100],
          labels: ['Inst 1','Inst 2','Inst 3','Inst 4','Inst 5','Inst 6'],
          windows: [
            { from:[12,1], to:[1,10] }, { from:[3,1], to:[3,15] }, { from:[4,1], to:[4,15] },
            { from:[5,1], to:[5,15] }, { from:[7,1], to:[7,15] }, { from:[9,1], to:[9,15] },
          ]
        },
        monthly: {
          type: 'monthly',
          weights: [2,1,1,1,1,1,2,1,1,1],
          labels: ['Jan (2 months)','Feb','Mar','Apr','May','Jun','Jul (2 months)','Aug','Sep','Oct'],
          windows: [
            { from:[1,1], to:[1,31] }, { from:[2,1], to:[2,28] }, { from:[3,1], to:[3,31] }, { from:[4,1], to:[4,30] },
            { from:[5,1], to:[5,31] }, { from:[6,1], to:[6,30] }, { from:[7,1], to:[7,31] },
            { from:[8,1], to:[8,31] }, { from:[9,1], to:[9,30] }, { from:[10,1], to:[10,31] },
          ]
        },
        '2inst': {
          type: '2',
          weights: [1,1], labels: ['1st Half','2nd Half'],
          windows: [ { from:[1,1], to:[1,10] }, { from:[7,1], to:[7,5] } ]
        },
        full: {
          type: 'full',
          weights: [1], labels: ['Full Year'],
          windows: [ { from:[1,1], to:[1,10] } ]
        }
      };

      function getConfig(student) {
        const plan = String(student.paymentPlan || '').toLowerCase();
        const c = String(student.classLevel || '').toLowerCase();
        if (plan.includes('monthly')) return installmentConfigs.monthly;
        if (plan.includes('2')) return installmentConfigs['2inst'];
        if (plan.includes('full') || plan.includes('year')) return installmentConfigs.full;
        if (plan.includes('inst')) {
          if (c === 'class 1' || c === 'class 2' || c === 'class 3') return installmentConfigs.lower;
          if (c === 'class 5') return installmentConfigs.class5;
          if (c === 'class 6') return installmentConfigs.class6;
          if (c === 'class 4' || c === 'class 7') return installmentConfigs.class4_7;
        }
        return installmentConfigs.lower;
      }

      function buildSchedule(student) {
        if (!student || student.isGraduated) {
          return { items: [], academicYear: targetYear, feeBase: 0 };
        }
        const config = getConfig(student);
        const feeBase = Math.max(0, Math.round(Number(student.baseFee ?? (student.feePerYear - (student.carryAmount || 0))) || 0));
        const carryAmount = Math.max(0, Number(student.carryAmount || 0));

        const amounts = apportion(feeBase, config.weights);
        if (carryAmount > 0) {
          if (amounts.length) amounts[0] += carryAmount;
          else amounts.push(carryAmount);
        }
        const items = config.labels.map((label, idx) => {
          const [fromM, fromD] = config.windows[idx].from;
          const [toM, toD] = config.windows[idx].to;
          return {
            label,
            amount: amounts[idx] || 0,
            fromTS: ymdToTS(targetYear, fromM, fromD, false),
            toTS:   ymdToTS(targetYear, toM, toD, true),
            paidAllocated: 0,
            status: 'Pending'
          };
        });
        return { items, academicYear: targetYear, feeBase };
      }

      function allocatePayments(schedule, student) {
        const payments = Object.values(student.payments || {})
          .map(p => ({
            amount: Math.max(0, Number(p.amount) || 0),
            ts: Number(p.timestamp || p.datePaid || 0),
          }))
          .filter(p => p.amount > 0)
          .sort((a, b) => a.ts - b.ts);
        const totalPaid = payments.reduce((a, b) => a + b.amount, 0);
        let pot = totalPaid;
        for (const it of schedule.items) {
          if (pot <= 0) break;
          const need = Math.max(0, it.amount - it.paidAllocated);
          const use = Math.min(need, pot);
          it.paidAllocated += use;
          pot -= use;
        }
        const credit = Math.max(0, pot);
        const now = nowTS();
        for (const it of schedule.items) {
          const got = it.paidAllocated, need = it.amount;
          if (got >= need) it.status = 'Cleared';
          else if (now > it.toTS) it.status = (got > 0) ? 'Partially Paid (Overdue)' : 'Overdue';
          else it.status = (got > 0) ? 'Partially Paid' : 'Pending';
        }
        const expectedToDate = schedule.items.filter(it => it.toTS < now).reduce((s, it) => s + it.amount, 0);
        const paidConsumed = totalPaid - credit;
        const debtTillNow = Math.max(0, expectedToDate - paidConsumed);
        return { credit, totalPaid, debtTillNow };
      }

      function render(student) {
        const fullName = `${student.firstName || ''} ${student.middleName || ''} ${student.lastName || ''}`.trim();
        if (student.isGraduated) {
          mount(`
            <div class="mb-2 flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
              <h2 class="font-semibold text-indigo-700">Installment Breakdown - ${fullName} (${student.admissionNumber || ''})</h2>
              <div class="text-xs">
                <span class="mr-3">Plan: <strong>${student.paymentPlan || ''}</strong></span>
                <span class="mr-3">Class: <strong>${student.classLevel || ''}</strong></span>
                <span>Year: <strong>${targetYearStr}</strong></span>
              </div>
            </div>
            <div class="p-4 border border-emerald-200 bg-emerald-50 text-emerald-700 text-sm rounded">
              This learner is marked as GRADUATED for ${targetYearStr}. No installments are scheduled for this year.
            </div>
          `);
          return;
        }

        const schedule = buildSchedule(student);
        const allocation = allocatePayments(schedule, student);
        const hasYearData = Boolean(student.hasYearData);

        const totalsExpRaw = schedule.items.reduce((s, it) => s + it.amount, 0);
        const totalsPaidRaw = schedule.items.reduce((s, it) => s + it.paidAllocated, 0);

        const totalsExp = hasYearData ? totalsExpRaw : 0;
        const totalsPaid = hasYearData ? totalsPaidRaw : 0;
        const totalPaidAll = hasYearData ? allocation.totalPaid : 0;
        const rem = hasYearData ? Math.max(0, totalsExp - totalsPaid) : 0;
        const debtValue = hasYearData ? allocation.debtTillNow : 0;
        const creditValue = hasYearData ? allocation.credit : 0;

        const prevYearLabel = targetYear - 1;
        const carryTag = student.carryAmount > 0
          ? `<span class="mr-3">Carry-forward ${prevYearLabel}: <strong>${fmt(student.carryAmount)}</strong></span>`
          : '';

        const rows = hasYearData && schedule.items.length
          ? schedule.items.map(it => {
              const remaining = Math.max(0, it.amount - it.paidAllocated);
              const win = new Date(it.fromTS).toLocaleDateString() + ' - ' + new Date(it.toTS).toLocaleDateString();
              const statusClass = it.status === 'Cleared'
                ? 'status-cleared'
                : (it.status.includes('Overdue') ? 'status-overdue' : 'status-partial');
              return `
                <tr>
                  <td class="p-1 border text-center">${it.label}</td>
                  <td class="p-1 border text-right">${fmt(it.amount)}</td>
                  <td class="p-1 border text-right">${fmt(it.paidAllocated)}</td>
                  <td class="p-1 border text-right">${fmt(remaining)}</td>
                  <td class="p-1 border text-center"><span class="status-pill ${statusClass}">${it.status}</span></td>
                  <td class="p-1 border text-center">${win}</td>
                </tr>`;
            }).join('')
          : '';

        const tableSection = hasYearData && schedule.items.length
          ? `
            <div class="overflow-auto border rounded">
              <table class="min-w-full text-xs">
                <thead>
                  <tr class="table-header">
                    <th class="p-1 border">Period</th>
                    <th class="p-1 border">Expected</th>
                    <th class="p-1 border">Allocated Paid</th>
                    <th class="p-1 border">Remaining</th>
                    <th class="p-1 border">Status</th>
                    <th class="p-1 border">Window</th>
                  </tr>
                </thead>
                <tbody>${rows}</tbody>
              </table>
            </div>`
          : `
            <div class="p-4 border border-dashed border-slate-200 rounded text-xs text-slate-500">
              No installment schedule for ${targetYearStr} yet.
            </div>`;

        const infoNote = !hasYearData
          ? `<div class="mb-3 text-xs text-slate-500 bg-slate-50 border border-slate-200 rounded p-3">
              No finance data has been recorded for ${targetYearStr}. Once this year's fee structure or payments are captured, the breakdown will appear here.
            </div>`
          : '';

        mount(`
          <div class="mb-2 flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
            <h2 class="font-semibold text-indigo-700">Installment Breakdown - ${fullName} (${student.admissionNumber || ''})</h2>
            <div class="text-xs">
              <span class="mr-3">Plan: <strong>${student.paymentPlan || ''}</strong></span>
              <span class="mr-3">Class: <strong>${student.classLevel || ''}</strong></span>
              <span>Year: <strong>${targetYearStr}</strong></span>
            </div>
          </div>

          <div class="mb-3 flex flex-col gap-2 text-xs md:flex-row md:items-center md:justify-between">
            <div class="flex flex-wrap items-center gap-3">
              <span>Fee (year): <strong>${fmt(hasYearData ? student.feePerYear : 0)}</strong></span>
              <span>Base: <strong>${fmt(student.baseFee || 0)}</strong></span>
              ${carryTag}
            </div>
            <div class="flex flex-wrap items-center gap-3">
              <span>Paid (total): <strong>${fmt(totalPaidAll)}</strong></span>
              <span>Allocated: <strong>${fmt(totalsPaid)}</strong></span>
              <span>Remaining: <strong>${fmt(rem)}</strong></span>
              <span>Debt till now: <strong>${fmt(debtValue)}</strong></span>
              <span>Credit: <strong>${fmt(creditValue)}</strong></span>
            </div>
          </div>

          ${infoNote}
          ${tableSection}
        `);
      }

      // ---- load student and render ----
      const studentId = new URL(location.href).searchParams.get('student');
      window.__STUDENT_ID__ = studentId;
      if (!studentId) { err('Error: No student ID provided in URL.'); return; }
      Promise.all([
        db.ref(`students/${studentId}`).once('value'),
        db.ref(`enrollments/${SOMAP_DEFAULT_YEAR}/${studentId}`).once('value'),
        db.ref(`enrollments/${targetYearStr}/${studentId}`).once('value'),
        db.ref(`feesStructure/${targetYearStr}`).once('value'),
        db.ref(`studentFees/${targetYearStr}/${studentId}`).once('value'),
        db.ref(`financeLedgers/${targetYearStr}/${studentId}/payments`).once('value'),
        db.ref(`financeCarryForward/${targetYearStr}/${studentId}`).once('value'),
      ])
        .then(async ([studentSnap, anchorSnap, enrollmentSnap, classFeesSnap, overrideSnap, ledgerSnap, carrySnap]) => {
          const baseStudent = studentSnap.val();
          if (!baseStudent) { err('Student not found.'); return; }

          const anchor = anchorSnap.val() || {};
          const enrollment = enrollmentSnap.val() || {};
          const classFees = classFeesSnap.val() || {};
          const override = overrideSnap.val() || {};
          const carry = carrySnap.val() || {};

          let paymentsSource = extractPaymentsMap(ledgerSnap.val(), targetYear);
          if (!Object.keys(paymentsSource).length) {
            try {
              const altSnap = await db.ref(`financeLedgers/${studentId}/${targetYearStr}/payments`).once('value');
              paymentsSource = extractPaymentsMap(altSnap.val(), targetYear);
            } catch (altErr) {
              console.warn('Legacy ledger path (payments) read failed', altErr?.message || altErr);
            }
          }
          if (!Object.keys(paymentsSource).length) {
            try {
              const altBucketSnap = await db.ref(`financeLedgers/${studentId}/${targetYearStr}`).once('value');
              paymentsSource = extractPaymentsMap(altBucketSnap.val(), targetYear);
            } catch (legacyBucketErr) {
              console.warn('Legacy ledger path (bucket) read failed', legacyBucketErr?.message || legacyBucketErr);
            }
          }
          if (!Object.keys(paymentsSource).length) {
            try {
              const altRootSnap = await db.ref(`financeLedgers/${studentId}`).once('value');
              paymentsSource = extractPaymentsMap(altRootSnap.val(), targetYear);
            } catch (legacyRootErr) {
              console.warn('Legacy ledger root read failed', legacyRootErr?.message || legacyRootErr);
            }
          }

          const baseClass =
            anchor.className ||
            anchor.classLevel ||
            baseStudent.classLevel ||
            baseStudent.class ||
            enrollment.className ||
            enrollment.classLevel ||
            '';
          const deltaYears = targetYear - SOMAP_DEFAULT_YEAR;
          const classLevel = shiftClass(baseClass, deltaYears);
          const classDefaults = classFees[classLevel] || classFees[baseClass] || {};

          const baseFeeCandidate =
            override.feePerYear ??
            classDefaults.feePerYear ??
            baseStudent.feePerYear ??
            baseStudent.feeDue ??
            baseStudent.requiredFee ??
            0;
          const baseFee = Math.max(0, Math.round(Number(baseFeeCandidate) || 0));
          const carryAmount = Math.max(0, Number(carry.amount ?? carry.balance ?? 0));
          const effectiveFee = Math.max(0, baseFee + carryAmount);

          let payments = normalizeLedgerPayments(paymentsSource, targetYear);
          if (!Object.keys(payments).length) {
            const overridePayments = normalizeLedgerPayments(coercePaymentMap(override.payments), targetYear);
            if (Object.keys(overridePayments).length) payments = overridePayments;
          }
          if (!Object.keys(payments).length) {
            const enrollmentPayments = normalizeLedgerPayments(coercePaymentMap(enrollment.payments), targetYear);
            if (Object.keys(enrollmentPayments).length) payments = enrollmentPayments;
          }
          if (!Object.keys(payments).length) {
            const basePayments = normalizeLedgerPayments(coercePaymentMap(baseStudent.payments), targetYear);
            if (Object.keys(basePayments).length) payments = basePayments;
          }

          const hasYearData =
            (Object.keys(enrollment).length > 0) ||
            (Object.keys(override).length > 0) ||
            (Object.keys(payments).length > 0) ||
            (classDefaults && Object.keys(classDefaults).length > 0) ||
            carryAmount > 0;

          const planName =
            override.planName ||
            override.paymentPlan ||
            enrollment.planName ||
            enrollment.paymentPlan ||
            classDefaults.defaultPlan ||
            baseStudent.paymentPlan ||
            '6-instalments';

          const prepared = {
            ...baseStudent,
            academicYear: targetYearStr,
            classLevel,
            paymentPlan: planName,
            baseFee,
            carryAmount,
            feePerYear: effectiveFee,
            payments,
            hasYearData,
            isGraduated: classLevel === 'GRADUATED',
            admissionNumber: enrollment.admissionNumber || enrollment.admissionNo || baseStudent.admissionNumber || studentId,
          };

          render(prepared);
        })
        .catch(e => { console.error(e); err('Error loading student data.'); });

      // resize again after fonts/images settle
      window.addEventListener('load', () => {
        const h = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
        try { window.parent.postMessage({ type:'resizeIframe', id: window.__STUDENT_ID__, height: h }, '*'); } catch {}
      });
    })();
  </script>
</body>
</html>



