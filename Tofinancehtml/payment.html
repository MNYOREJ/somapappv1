<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Installment Breakdown</title>

  <!-- Firebase (v9 compat) -->
  <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-database-compat.js"></script>
  <script src="../shared/finance_math.js"></script>

  <!-- Tailwind for quick styling -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"/>

  <style>
    .status-pill { padding:2px 8px; border-radius:999px; font-size: 11px; font-weight:600; }
    .status-cleared { background:#dcfce7; color:#166534; }
    .status-partial { background:#fef9c3; color:#854d0e; }
    .status-overdue { background:#fee2e2; color:#991b1b; }
    .table-header { background:#eef2ff; color:#1f2937; }
  </style>
  <script>
    window.SOMAP_DEFAULT_YEAR = window.SOMAP_DEFAULT_YEAR || 2025;
    window.somapYearContext = window.somapYearContext || (function(){
      let selected = (sessionStorage.getItem('somap_selected_year') || String(window.SOMAP_DEFAULT_YEAR));
      const listeners = new Set();
      return {
        getSelectedYear(){ return String(selected); },
        setSelectedYear(y){
          y = String(y);
          if (selected === y) return;
          selected = y;
          try{ sessionStorage.setItem('somap_selected_year', y); }catch{}
          listeners.forEach(fn => { try{ fn(y); }catch{} });
        },
        onYearChanged(fn){ if (typeof fn==='function') listeners.add(fn); }
      };
    })();

    const getDb = () => {
      if (window.db) return window.db;
      try {
        if (firebase?.apps?.length) return firebase.database();
        if (firebase?.database) return firebase.database();
      } catch (_) {}
      return null;
    };
    window.__somapGetDb = getDb;
    const safeNum = window.__somapSafeNum || (window.__somapSafeNum = (v => (v === null || v === undefined) ? 0 : Number(v) || 0));
    const fmt = window.__somapFmtCurrency || (window.__somapFmtCurrency = (n => `TSh ${Number(n || 0).toLocaleString('en-US')}`));
    window.somapFmt = fmt;
    window.somapFmtCurrency = fmt;
    const __ledgerCache = window.__somapLedgerCache || (window.__somapLedgerCache = {});
    const __feeCache = window.__somapFeeCache || (window.__somapFeeCache = {});

    const sumYearPayments = window.sumYearPayments || (window.sumYearPayments = async function(year, studentId){
      const dbInstance = getDb();
      if (!dbInstance || !year || !studentId) return 0;
      const y = String(year);
      const id = String(studentId);
      const cacheKey = `${y}::${id}`;
      const cached = __ledgerCache[cacheKey];
      if (cached && cached.total !== undefined) return cached.total;
      try{
        let rows = {};
        const primaryRef = dbInstance.ref(`financeLedgers/${y}/${id}/payments`);
        const altRefA = dbInstance.ref(`financeLedgers/${id}/${y}/payments`);
        const altRefB = dbInstance.ref(`financeLedgers/${id}/${y}`);
        const altRefRoot = dbInstance.ref(`financeLedgers/${id}`);

        try {
          const snap = await primaryRef.once('value');
          rows = snap.val() || {};
        } catch (primaryErr) {
          console.warn('sumYearPayments primary path failed', y, id, primaryErr);
        }

        if (!rows || !Object.keys(rows).length) {
          try {
            const snap = await altRefA.once('value');
            rows = snap.val() || {};
          } catch (_) {}
        }

        if (!rows || !Object.keys(rows).length) {
          try {
            const snap = await altRefB.once('value');
            const val = snap.val();
            if (val && typeof val === 'object') {
              rows = val.payments || val.entries || val.records || val;
            }
          } catch (_) {}
        }

        if (!rows || !Object.keys(rows).length) {
          try {
            const snap = await altRefRoot.once('value');
            const all = snap.val() || {};
            const bucket = all[y] ?? all[String(y)] ?? all[Number(y)];
            if (bucket && typeof bucket === 'object') {
              rows = bucket.payments || bucket.entries || bucket.records || bucket;
            }
          } catch (_) {}
        }

        rows = rows && typeof rows === 'object' ? rows : {};
        let total = 0;
        Object.keys(rows).forEach(key => {
          const row = rows[key];
          const amount = safeNum(row?.amount ?? row?.paid ?? row?.value);
          total += amount;
          if (row && typeof row === 'object') {
            rows[key] = { ...row, amount };
            if (!rows[key].allocatedYear) rows[key].allocatedYear = y;
            rows[key].approvalId = rows[key].approvalId || key;
          } else {
            rows[key] = { amount, allocatedYear: y, approvalId: key };
          }
        });
        __ledgerCache[cacheKey] = { rows, total };
        return total;
      }catch(err){
        console.warn('sumYearPayments failed', y, id, err);
        return 0;
      }
    });

    const getYearFee = window.getYearFee || (window.getYearFee = async function(year, studentId){
      const dbInstance = getDb();
      if (!dbInstance || !year || !studentId) return 0;
      const y = String(year);
      const id = String(studentId);
      const cacheKey = `${y}::${id}`;
      if (__feeCache[cacheKey] !== undefined) return __feeCache[cacheKey];
      try{
        const snap = await dbInstance.ref(`studentFees/${y}/${id}/feePerYear`).once('value');
        const v1 = snap.val();
        const fee = (v1 !== null && v1 !== undefined) ? safeNum(v1) : 0;
        __feeCache[cacheKey] = fee;
        return fee;
      }catch(err){
        console.warn('getYearFee failed', y, id, err);
        return 0;
      }
    });
  </script>
</head>
<body class="bg-white">
  <div id="breakdownContent" class="text-sm p-4">
    <!-- skeleton loader -->
    <div id="skel" class="animate-pulse">
      <div class="h-4 bg-slate-200 rounded w-2/3 mb-3"></div>
      <div class="h-3 bg-slate-200 rounded w-full mb-2"></div>
      <div class="h-3 bg-slate-200 rounded w-5/6"></div>
    </div>
  </div>

  <script type="module">
    import { resolveEffectiveInstallments } from '../js/financeplans.js';
    (function () {
      const SOMAP_DEFAULT_YEAR = 2025;
      const CLASS_ORDER = ['Baby Class','Middle Class','Pre Unit Class','Class 1','Class 2','Class 3','Class 4','Class 5','Class 6','Class 7'];
      const norm = (s) => String(s || '').trim().toLowerCase();
      function shiftClass(baseName, deltaYears) {
        const i = CLASS_ORDER.findIndex((c) => norm(c) === norm(baseName));
        if (i < 0) return baseName || '';
        const j = i + Number(deltaYears || 0);
        if (j < 0) return 'PRE-ADMISSION';
        if (j >= CLASS_ORDER.length) return 'GRADUATED';
        return CLASS_ORDER[j];
      }

      // ---- Parent scope detection ----
      const q = new URL(location.href).searchParams;
      const isParentScope = (q.get('scope')||'').toLowerCase() === 'parent';
      const targetYearNum = Number(q.get('year') || SOMAP_DEFAULT_YEAR);
      const targetYear = Number.isFinite(targetYearNum) ? targetYearNum : SOMAP_DEFAULT_YEAR;
      const targetYearStr = String(targetYear);
      const CARRY_FORWARD_START_YEAR = 2025;

      const sumYearPaymentsFn = window.sumYearPayments || (async () => 0);
      const getYearFeeFn = window.getYearFee || (async () => 0);

      const carryForwardCache = new Map();
      async function fetchPrevYearCarry(admRaw) {
        const normalized = String(admRaw || '').trim();
        if (!normalized) return 0;
        const cacheKey = `${targetYearStr}::${normalized}`;
        if (carryForwardCache.has(cacheKey)) return carryForwardCache.get(cacheKey);
        const prevYear = targetYear - 1;
        if (!Number.isFinite(prevYear) || prevYear < CARRY_FORWARD_START_YEAR) {
          carryForwardCache.set(cacheKey, 0);
          return 0;
        }
        let amount = 0;
        try {
          const shared = window.parent && window.parent.__financeCarryForwardVisual
            ? window.parent.__financeCarryForwardVisual[cacheKey]
            : null;
          if (shared && shared.carry) amount = Number(shared.carry) || 0;
        } catch (_) {}
        if (!amount) {
          try {
            const stored = sessionStorage.getItem(`somap_cf_${targetYearStr}_${normalized}`);
            if (stored) amount = Number(stored) || 0;
          } catch (_) {}
        }
        if (!amount && window.parent && typeof window.parent.__finance_getBalanceForYearAdmission === 'function') {
          try {
            const val = await window.parent.__finance_getBalanceForYearAdmission(prevYear, normalized);
            amount = Number(val) || 0;
          } catch (_) {}
        }
        if (!amount && typeof window.__finance_getBalanceForYearAdmission === 'function') {
          try {
            const val = await window.__finance_getBalanceForYearAdmission(prevYear, normalized);
            amount = Number(val) || 0;
          } catch (_) {}
        }
        if (!amount && window.firebase?.database) {
          try {
            const snap = await window.firebase.database().ref(`finance/${prevYear}/students/${normalized}`).get();
            if (snap.exists()) {
              const data = snap.val() || {};
              if (data.balance !== undefined) amount = Number(data.balance) || 0;
              else {
                const feeYear = Number(String(data.feeYear || data.fee || 0).replace(/[^\d]/g, '')) || 0;
                const paid = Number(String(data.paid || 0).replace(/[^\d]/g, '')) || 0;
                amount = Math.max(0, feeYear - paid);
              }
            }
          } catch (err) {
            console.warn('Carry-forward fetch fallback failed', normalized, prevYear, err);
          }
        }
        amount = Math.max(0, Number(amount) || 0);
        carryForwardCache.set(cacheKey, amount);
        return amount;
      }

      window.__somap_fetchCarryForward = async function(year, adm) {
        const y = Number(year);
        if (Number.isFinite(y) && y === targetYear) {
          return fetchPrevYearCarry(adm);
        }
        if (window.parent && typeof window.parent.__somap_fetchCarryForward === 'function') {
          return window.parent.__somap_fetchCarryForward(year, adm);
        }
        return 0;
      };

      // ---- Firebase init (inline, so the iframe never depends on ../firebase.js) ----
      const firebaseConfig = {
        apiKey: "AIzaSyBhONntRE_aRsU0y1YcPZzWud3CBfwH_a8",
        authDomain: "somaptestt.firebaseapp.com",
        databaseURL: "https://somaptestt-default-rtdb.firebaseio.com",
        projectId: "somaptestt",
        storageBucket: "somaptestt.appspot.com",
        messagingSenderId: "105526245138",
        appId: "1:105526245138:web:b8e7c0cb82a46e861965cb",
        measurementId: "G-4HKX7KN6Q3"
      };
      try { if (!firebase?.apps?.length) firebase.initializeApp(firebaseConfig); }
      catch (e) { console.error('Firebase init error', e); }
      const db = (() => { try { return firebase.database(); } catch { return null; }})();

      const mount = (html) => {
        const el = document.getElementById('breakdownContent');
        el.innerHTML = html;
        // ask parent to resize this iframe
        const h = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
        try { window.parent.postMessage({ type:'resizeIframe', id: window.__STUDENT_ID__, height: h }, '*'); } catch {}
      };
      const err = (msg) => mount(`<div class="p-3 rounded bg-rose-50 text-rose-700 border border-rose-200">${msg}</div>`);

      if (!db) { err('Error: Database not initialized. Please check Firebase credentials or internet connection.'); return; }

      // ---- helpers ----
      const fmt = window.somapFmt || (n => `TSh ${Number(n || 0).toLocaleString('en-US')}`);
      const safeNumLocal = window.__somapSafeNum || (v => (v === null || v === undefined) ? 0 : Number(v) || 0);
      const nowTS = () => Date.now();
      function ymdToTS(academicYear, m, d, endOfDay = false) {
        const y = (m === 12) ? (Number(academicYear) - 1) : Number(academicYear);
        return endOfDay
          ? new Date(y, m - 1, d, 23, 59, 59, 999).getTime()
          : new Date(y, m - 1, d, 0, 0, 0, 0).getTime();
      }
      function apportion(total, weights) {
        if (!Array.isArray(weights) || !weights.length) return [];
        const sumW = weights.reduce((a, b) => a + b, 0);
        let amounts = weights.map(w => Math.floor((w * total) / sumW));
        let sumA = amounts.reduce((a, b) => a + b, 0);
        let rem = total - sumA;
        if (rem > 0) {
          const sortedIdx = [...weights.keys()].sort((a, b) => weights[b] - weights[a]);
          for (let i = 0; i < rem; i++) amounts[sortedIdx[i % sortedIdx.length]]++;
        }
        return amounts;
      }

      function coercePaymentMap(raw) {
        if (!raw) return {};
        if (Array.isArray(raw)) {
          return raw.reduce((acc, entry, idx) => {
            if (entry != null) acc[`idx-${idx}`] = entry;
            return acc;
          }, {});
        }
        if (typeof raw === 'object') return { ...raw };
        return {};
      }

      function extractPaymentsMap(raw, targetYear) {
        if (!raw || typeof raw !== 'object') return {};
        const yearKey = String(targetYear);
        const numericYear = Number(targetYear);

        if (raw.payments || raw.entries || raw.records) {
          return coercePaymentMap(raw.payments || raw.entries || raw.records);
        }

        const possibleBucket =
          raw[yearKey] ??
          raw[String(numericYear)] ??
          raw[numericYear];
        if (possibleBucket && typeof possibleBucket === 'object') {
          if (possibleBucket.payments || possibleBucket.entries || possibleBucket.records) {
            return coercePaymentMap(possibleBucket.payments || possibleBucket.entries || possibleBucket.records);
          }
          return coercePaymentMap(possibleBucket);
        }

        return coercePaymentMap(raw);
      }

      function normalizeLedgerPayments(source, targetYear) {
        const normalized = {};
        if (!source) return normalized;
        const desiredYear = Number(targetYear);
        Object.entries(source).forEach(([key, raw]) => {
          if (!raw) return;
          const amount = Number(raw.amount ?? raw.value ?? raw.paid ?? raw.payment ?? raw.total ?? 0);
          if (!Number.isFinite(amount) || amount <= 0) return;
          const timestamp = Number(
            raw.timestamp ?? raw.datePaid ?? raw.createdAt ?? raw.recordedAt ?? raw.updatedAt ?? raw.time ?? Date.now()
          );
          let paymentYear = Number(
            raw.academicYear ??
            raw.financeYear ??
            raw.feeYear ??
            raw.year ??
            raw._year ??
            raw.academic_session
          );
          if (!Number.isFinite(paymentYear) && Number.isFinite(timestamp)) {
            const ts = new Date(timestamp);
            if (!Number.isNaN(ts.getTime())) paymentYear = ts.getFullYear();
          }
          if (Number.isFinite(desiredYear) && Number.isFinite(paymentYear) && paymentYear !== desiredYear) return;
          const payload = { ...raw, amount: Math.round(Math.max(0, amount)), timestamp };
          if (Number.isFinite(paymentYear)) payload.academicYear = paymentYear;
          else if (Number.isFinite(desiredYear)) payload.academicYear = desiredYear;
          normalized[key] = payload;
        });
        return normalized;
      }

      // ---- installment configs (DISCOUNTS REMOVED) ----
      const installmentConfigs = {
        lower: {
          type: '6', weights: [44, 13, 12, 22, 22, 16],
          labels: ['Inst 1','Inst 2','Inst 3','Inst 4','Inst 5','Inst 6'],
          windows: [
            { from:[12,1], to:[1,10] }, { from:[3,1], to:[3,15] }, { from:[4,1], to:[4,15] },
            { from:[5,1], to:[5,15] }, { from:[7,1], to:[7,15] }, { from:[9,1], to:[9,15] },
          ]
        },
        class4_7: {
          type: '4', weights: [328, 180, 176, 132],
          labels: ['Inst 1','Inst 2','Inst 3','Inst 4'],
          windows: [
            { from:[12,1], to:[1,10] }, { from:[3,1], to:[3,15] }, { from:[4,1], to:[4,15] }, { from:[5,1], to:[5,15] }
          ]
        },
        class5: {
          type: '6', weights: [44, 23, 22, 32, 26, 17],
          labels: ['Inst 1','Inst 2','Inst 3','Inst 4','Inst 5','Inst 6'],
          windows: [
            { from:[12,1], to:[1,10] }, { from:[3,1], to:[3,15] }, { from:[4,1], to:[4,15] },
            { from:[5,1], to:[5,15] }, { from:[7,1], to:[7,15] }, { from:[9,1], to:[9,15] },
          ]
        },
        class6: {
          type: '6', weights: [236, 115, 110, 160, 160, 100],
          labels: ['Inst 1','Inst 2','Inst 3','Inst 4','Inst 5','Inst 6'],
          windows: [
            { from:[12,1], to:[1,10] }, { from:[3,1], to:[3,15] }, { from:[4,1], to:[4,15] },
            { from:[5,1], to:[5,15] }, { from:[7,1], to:[7,15] }, { from:[9,1], to:[9,15] },
          ]
        },
        monthly: {
          type: 'monthly',
          weights: [2,1,1,1,1,1,2,1,1,1],
          labels: ['Jan (2 months)','Feb','Mar','Apr','May','Jun','Jul (2 months)','Aug','Sep','Oct'],
          windows: [
            { from:[1,1], to:[1,31] }, { from:[2,1], to:[2,28] }, { from:[3,1], to:[3,31] }, { from:[4,1], to:[4,30] },
            { from:[5,1], to:[5,31] }, { from:[6,1], to:[6,30] }, { from:[7,1], to:[7,31] },
            { from:[8,1], to:[8,31] }, { from:[9,1], to:[9,30] }, { from:[10,1], to:[10,31] },
          ]
        },
        '2inst': {
          type: '2',
          weights: [1,1], labels: ['1st Half','2nd Half'],
          windows: [ { from:[1,1], to:[1,10] }, { from:[7,1], to:[7,5] } ]
        },
        full: {
          type: 'full',
          weights: [1], labels: ['Full Year'],
          windows: [ { from:[1,1], to:[1,10] } ]
        }
      };

      function getConfig(student) {
        const plan = String(student.paymentPlan || '').toLowerCase();
        const c = String(student.classLevel || '').toLowerCase();
        if (plan.includes('monthly')) return installmentConfigs.monthly;
        if (plan.includes('2')) return installmentConfigs['2inst'];
        if (plan.includes('full') || plan.includes('year')) return installmentConfigs.full;
        if (plan.includes('inst')) {
          if (c === 'class 1' || c === 'class 2' || c === 'class 3') return installmentConfigs.lower;
          if (c === 'class 5') return installmentConfigs.class5;
          if (c === 'class 6') return installmentConfigs.class6;
          if (c === 'class 4' || c === 'class 7') return installmentConfigs.class4_7;
        }
        return installmentConfigs.lower;
      }

      function buildLegacySchedule(student) {
        if (!student || student.isGraduated) {
          return { items: [], academicYear: targetYear, feeBase: 0, planName: student?.paymentPlan || '' };
        }
        const config = getConfig(student);
        const feeBase = Math.max(0, Math.round(Number(student.baseFee ?? (student.feePerYear - (student.carryAmount || 0))) || 0));
        const carryAmount = Math.max(0, Number(student.carryAmount || 0));
        const weights = Array.isArray(config?.weights) ? config.weights : [];
        const labels = Array.isArray(config?.labels) ? config.labels : [];
        const windows = Array.isArray(config?.windows) ? config.windows : [];

        const amounts = apportion(feeBase, weights);
        if (carryAmount > 0) {
          if (amounts.length) amounts[0] += carryAmount;
          else amounts.push(carryAmount);
        }

        const items = labels.map((label, idx) => {
          const win = windows[idx] || windows[windows.length - 1] || { from: [1, 1], to: [1, 10] };
          const [fromM, fromD] = win.from;
          const [toM, toD] = win.to;
          return {
            label,
            amount: amounts[idx] || 0,
            fromTS: ymdToTS(targetYear, fromM, fromD, false),
            toTS: ymdToTS(targetYear, toM, toD, true),
            paidAllocated: 0,
            status: 'Pending',
          };
        });
        return { items, academicYear: targetYear, feeBase, planName: student.paymentPlan || '' };
      }

      function fallbackWindow(config, idx) {
        if (!config || !Array.isArray(config.windows) || !config.windows.length) return null;
        return config.windows[idx] || config.windows[config.windows.length - 1];
      }

      function resolveWindowPair(row, key, fallbackPair) {
        if (!row) return fallbackPair || null;
        const monthKey = `${key}Month`;
        const dayKey = `${key}Day`;
        if (row[monthKey] !== undefined && row[dayKey] !== undefined) {
          const m = Number(row[monthKey]);
          const d = Number(row[dayKey]);
          if (Number.isFinite(m) && Number.isFinite(d) && m > 0 && d > 0) return [m, d];
        }
        const direct = row[key] || row[`${key}Date`];
        if (direct) {
          const match = String(direct).match(/(\d{1,2})\D*(\d{1,2})/);
          if (match) {
            const m = Number(match[1]);
            const d = Number(match[2]);
            if (Number.isFinite(m) && Number.isFinite(d) && m > 0 && d > 0) return [m, d];
          }
        }
        if (row.windowText) {
          const segments = String(row.windowText).split('–');
          const idx = key === 'from' ? 0 : 1;
          if (segments[idx]) {
            const match = segments[idx].match(/(\d{1,2})\D*(\d{1,2})/);
            if (match) {
              const m = Number(match[1]);
              const d = Number(match[2]);
              if (Number.isFinite(m) && Number.isFinite(d) && m > 0 && d > 0) return [m, d];
            }
          }
        }
        return fallbackPair || null;
      }

      function toAcademicTS(pair, endOfDay) {
        let [month, day] = Array.isArray(pair) ? pair : [1, 1];
        month = Number(month);
        day = Number(day);
        if (!Number.isFinite(month) || month <= 0 || month > 12) month = 1;
        if (!Number.isFinite(day) || day <= 0 || day > 31) day = endOfDay ? 10 : 1;
        return ymdToTS(targetYear, month, day, endOfDay);
      }

      async function buildSchedule(student, classDefaults, override) {
        if (!student || student.isGraduated) {
          return { items: [], academicYear: targetYear, feeBase: 0, planName: student?.paymentPlan || '' };
        }
        const config = getConfig(student);
        
        // PRIORITY 1: Check for student custom schedule (highest priority override)
        if (override && Array.isArray(override.customSchedule) && override.customSchedule.length > 0) {
          // Student has custom schedule - let resolveEffectiveInstallments handle it
          // Fall through to PRIORITY 2
        }
        
        // PRIORITY 2: Check if class-level edited installments exist (from paymentedits.html)
        // These are stored in feesStructure/{year}/{Class}/installments
        // Only use if student doesn't have a custom schedule or plan override
        const hasStudentOverride = override && (
          (Array.isArray(override.customSchedule) && override.customSchedule.length > 0) ||
          override.planId
        );
        
        if (!hasStudentOverride && classDefaults && classDefaults.installments && typeof classDefaults.installments === 'object') {
          const installmentsObj = classDefaults.installments;
          const entries = Object.values(installmentsObj).filter(inst => inst && inst.active !== false);
          
          if (entries.length > 0) {
            // Sort by window date (from month/day)
            const sorted = entries.slice().sort((a, b) => {
              const af = (a?.window?.from || []);
              const bf = (b?.window?.from || []);
              if (!af.length && !bf.length) return 0;
              if (!af.length) return 1;
              if (!bf.length) return -1;
              if (af[0] !== bf[0]) return af[0] - bf[0];
              return af[1] - bf[1];
            });
            
            const items = sorted.map((inst, idx) => {
              const win = inst?.window || {};
              const fromPair = Array.isArray(win.from) ? win.from : null;
              const toPair = Array.isArray(win.to) ? win.to : null;
              const fallback = fallbackWindow(config, idx) || { from: [1, 1], to: [1, 10] };
              const amount = Math.max(0, Math.round(Number(inst?.amount) || 0));
              const label = inst?.label || (config?.labels?.[idx] || `Inst ${idx + 1}`);
              
              return {
                label,
                amount,
                fromTS: toAcademicTS(fromPair || fallback.from, false),
                toTS: toAcademicTS(toPair || fallback.to, true),
                paidAllocated: 0,
                status: 'Pending',
                weight: Number(inst?.weight || 0),
                windowText: inst?.windowText || ''
              };
            });
            
            // Add carry forward if exists
            const carryAmount = Math.max(0, Number(student.carryAmount || 0));
            if (carryAmount > 0 && items.length) {
              items[0].amount += carryAmount;
            }
            
            const feeBase = Math.max(0, Math.round(Number(classDefaults.feePerYear || student.baseFee || student.feePerYear || 0)));
            
            return {
              items,
              academicYear: targetYear,
              feeBase,
              planName: classDefaults.defaultPlan || classDefaults.defaultPlanId || student.paymentPlan || '',
              planId: classDefaults.defaultPlanId || ''
            };
          }
        }
        
        // PRIORITY 3: Try resolveEffectiveInstallments (handles student overrides, custom schedules, plan overrides)
        let breakdown = null;
        try {
          breakdown = await resolveEffectiveInstallments(
            studentId,
            student.classLevel || student.className || student.class || '',
            { year: targetYearStr }
          );
        } catch (err) {
          console.warn('resolveEffectiveInstallments error', err);
        }
        const rows = Array.isArray(breakdown?.rows) ? breakdown.rows : [];
        if (!rows.length) {
          // PRIORITY 4: Fall back to legacy apportioning
          return buildLegacySchedule(student);
        }

        const items = rows.map((row, idx) => {
          const fallback = fallbackWindow(config, idx) || { from: [1, 1], to: [1, 10] };
          const fromPair = resolveWindowPair(row, 'from', fallback.from);
          const toPair = resolveWindowPair(row, 'to', fallback.to);
          const amount = Math.max(0, Math.round(Number(row.amount) || 0));
          const label = row.label || (config?.labels?.[idx] || `Inst ${idx + 1}`);
          return {
            label,
            amount,
            fromTS: toAcademicTS(fromPair, false),
            toTS: toAcademicTS(toPair, true),
            paidAllocated: 0,
            status: 'Pending',
            weight: Number(row.weight || 0),
            windowText: row.windowText || '',
          };
        });

        const carryAmount = Math.max(0, Number(student.carryAmount || 0));
        if (carryAmount > 0) {
          if (items.length) {
            items[0].amount += carryAmount;
          } else {
            const fallback = fallbackWindow(config, 0) || { from: [1, 1], to: [1, 10] };
            items.push({
              label: 'Carry Forward',
              amount: carryAmount,
              fromTS: toAcademicTS(fallback.from, false),
              toTS: toAcademicTS(fallback.to, true),
              paidAllocated: 0,
              status: 'Pending',
              weight: 0,
              windowText: '',
            });
          }
        }

        return {
          items,
          academicYear: targetYear,
          feeBase: breakdown?.fee ?? 0,
          planName: breakdown?.planName || breakdown?.planId || student.paymentPlan || '',
          planId: breakdown?.planId || '',
        };
      }

      function windowLabelForSort(item){
        const fmt = (ts) => {
          const d = new Date(ts || 0);
          return `${d.getMonth() + 1}/${d.getDate()}/${d.getFullYear()}`;
        };
        return `${fmt(item.fromTS)} - ${fmt(item.toTS)}`;
      }

      function sortScheduleItems(items){
        if (!Array.isArray(items)) return;
        const comparator = window.SomapFinance?.installmentCompare;
        if (typeof comparator === 'function') {
          items.sort((a, b) => comparator(
            { label: a.label, window: windowLabelForSort(a) },
            { label: b.label, window: windowLabelForSort(b) }
          ));
        } else {
          items.sort((a, b) => (a.fromTS || 0) - (b.fromTS || 0));
        }
      }

      function allocatePayments(schedule, student) {
        const payments = Object.values(student.payments || {})
          .map(p => ({
            amount: Math.max(0, Number(p.amount) || 0),
            ts: Number(p.timestamp || p.datePaid || 0),
          }))
          .filter(p => p.amount > 0)
          .sort((a, b) => a.ts - b.ts);
        const totalPaid = payments.reduce((a, b) => a + b.amount, 0);
        let pot = totalPaid;
        for (const it of schedule.items) {
          if (pot <= 0) break;
          const need = Math.max(0, it.amount - it.paidAllocated);
          const use = Math.min(need, pot);
          it.paidAllocated += use;
          pot -= use;
        }
        const credit = Math.max(0, pot);
        const now = nowTS();
        for (const it of schedule.items) {
          const got = it.paidAllocated, need = it.amount;
          if (got >= need) it.status = 'Cleared';
          else if (now > it.toTS) it.status = (got > 0) ? 'Partially Paid (Overdue)' : 'Overdue';
          else it.status = (got > 0) ? 'Partially Paid' : 'Pending';
        }
        const expectedToDate = schedule.items.filter(it => it.toTS < now).reduce((s, it) => s + it.amount, 0);
        const paidConsumed = totalPaid - credit;
        const debtTillNow = Math.max(0, expectedToDate - paidConsumed);
        return { credit, totalPaid, debtTillNow };
      }

      async function render(student, classDefaults, override, context = {}) {
        const targetYearOverride = String(context.targetYear || targetYearStr);
        const ctxStudentId = context.studentId || studentId;
        const mismatches = Array.isArray(context.mismatches) ? context.mismatches : [];
        const totalPaidYear = safeNumLocal(context.totalPaidYear || 0);
        const fullName = `${student.firstName || ''} ${student.middleName || ''} ${student.lastName || ''}`.trim();
        if (student.isGraduated) {
          mount(`
            <div class="mb-2 flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
              <h2 class="font-semibold text-indigo-700">Installment Breakdown - ${fullName} (${student.admissionNumber || ''})</h2>
              <div class="text-xs">
                <span class="mr-3">Plan: <strong>${student.paymentPlan || ''}</strong></span>
                <span class="mr-3">Class: <strong>${student.classLevel || ''}</strong></span>
                <span>Year: <strong>${targetYearStr}</strong></span>
              </div>
            </div>
            <div class="p-4 border border-emerald-200 bg-emerald-50 text-emerald-700 text-sm rounded">
              This learner is marked as GRADUATED for ${targetYearStr}. No installments are scheduled for this year.
            </div>
          `);
          return;
        }

        const schedule = await buildSchedule(student, classDefaults, override);
        schedule.items = Array.isArray(schedule?.items) ? schedule.items : [];
        sortScheduleItems(schedule.items);
        const planDisplay = schedule.planName || student.paymentPlan || '';
        const allocation = allocatePayments(schedule, student);
        const hasYearData = Boolean(student.hasYearData);
        const admissionForLookup = student.admissionNumber || studentId;
        const prevCarry = hasYearData ? await fetchPrevYearCarry(admissionForLookup) : 0;
        const dbCarry = Math.max(0, Number(student.carryAmount || 0));
        const effectiveCarry = Math.max(dbCarry, prevCarry);
        const inferredBaseFee = student.baseFee != null
          ? Math.max(0, Number(student.baseFee) || 0)
          : Math.max(0, Number(student.feePerYear || 0) - dbCarry);
        const totalDueWithCarry = hasYearData ? inferredBaseFee + effectiveCarry : 0;

        const totalsExpRaw = schedule.items.reduce((s, it) => s + it.amount, 0);
        const totalsPaidRaw = schedule.items.reduce((s, it) => s + it.paidAllocated, 0);

        const totalsExp = hasYearData ? totalsExpRaw : 0;
        const totalsPaid = hasYearData ? totalsPaidRaw : 0;
        const totalPaidAll = hasYearData
          ? (totalPaidYear > 0 ? totalPaidYear : allocation.totalPaid)
          : 0;
        const rem = hasYearData ? Math.max(0, totalsExp - totalsPaid) : 0;
        const remainingWithCarry = hasYearData
          ? Math.max(rem, totalDueWithCarry - totalPaidAll)
          : 0;
        const debtValue = hasYearData ? allocation.debtTillNow : 0;
        const debtWithCarry = hasYearData ? Math.max(0, debtValue + prevCarry) : 0;
        const creditValue = hasYearData ? allocation.credit : 0;

        const prevYearLabel = targetYear - 1;
        const carryParts = [];
        if (prevCarry > 0) carryParts.push(`Prev ${prevYearLabel}: <strong>${fmt(prevCarry)}</strong>`);
        if (dbCarry > 0 && dbCarry !== prevCarry) carryParts.push(`Ledger: <strong>${fmt(dbCarry)}</strong>`);
        const carryTag = carryParts.length
          ? `<span class="mr-3">Carry Forward (${prevYearLabel}+): ${carryParts.join(' + ')}</span>`
          : '';

        const rows = hasYearData && schedule.items.length
          ? schedule.items.map(it => {
              const remaining = Math.max(0, it.amount - it.paidAllocated);
              const win = new Date(it.fromTS).toLocaleDateString() + ' - ' + new Date(it.toTS).toLocaleDateString();
              const statusClass = it.status === 'Cleared'
                ? 'status-cleared'
                : (it.status.includes('Overdue') ? 'status-overdue' : 'status-partial');
              return `
                <tr>
                  <td class="p-1 border text-center">${it.label}</td>
                  <td class="p-1 border text-right">${fmt(it.amount)}</td>
                  <td class="p-1 border text-right">${fmt(it.paidAllocated)}</td>
                  <td class="p-1 border text-right">${fmt(remaining)}</td>
                  <td class="p-1 border text-center"><span class="status-pill ${statusClass}">${it.status}</span></td>
                  <td class="p-1 border text-center">${win}</td>
                </tr>`;
            }).join('')
          : '';

        const tableSection = hasYearData && schedule.items.length
          ? `
            <div class="overflow-auto border rounded">
              <table class="min-w-full text-xs">
                <thead>
                  <tr class="table-header">
                    <th class="p-1 border">Period</th>
                    <th class="p-1 border">Expected</th>
                    <th class="p-1 border">Allocated Paid</th>
                    <th class="p-1 border">Remaining</th>
                    <th class="p-1 border">Status</th>
                    <th class="p-1 border">Window</th>
                  </tr>
                </thead>
                <tbody>${rows}</tbody>
              </table>
            </div>`
          : `
            <div class="p-4 border border-dashed border-slate-200 rounded text-xs text-slate-500">
              No installment schedule for ${targetYearStr} yet.
            </div>`;

        const infoNote = !hasYearData
          ? `<div class="mb-3 text-xs text-slate-500 bg-slate-50 border border-slate-200 rounded p-3">
              No finance data has been recorded for ${targetYearStr}. Once this year's fee structure or payments are captured, the breakdown will appear here.
            </div>`
          : '';

        mount(`
          <div class="mb-2 flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
            <h2 class="font-semibold text-indigo-700">Installment Breakdown - ${fullName} (${student.admissionNumber || ''})</h2>
            <div class="text-xs">
              <span class="mr-3">Plan: <strong>${planDisplay}</strong></span>
              <span class="mr-3">Class: <strong>${student.classLevel || ''}</strong></span>
              <span>Year: <strong>${targetYearStr}</strong></span>
            </div>
          </div>

          <div class="mb-3 flex flex-col gap-2 text-xs md:flex-row md:items-center md:justify-between">
            <div class="flex flex-wrap items-center gap-3">
              <span data-cf-fee-year>
                Fee (incl. carry):
                <strong
                  data-base-fee="${inferredBaseFee}"
                  data-base-value="${inferredBaseFee}"
                  data-initial-carry="${effectiveCarry}"
                >${fmt(totalDueWithCarry)}</strong>
              </span>
              <span data-cf-base-fee>Base: <strong>${fmt(inferredBaseFee)}</strong></span>
              <span data-cf-carry-slot>${carryTag || ''}</span>
            </div>
            <div class="flex flex-wrap items-center gap-3">
              <span data-cf-paid-total>Paid (total): <strong>${fmt(totalPaidAll)}</strong></span>
              <span data-cf-allocated>Allocated: <strong>${fmt(totalsPaid)}</strong></span>
              <span data-cf-remaining>
                Remaining:
                <strong
                  data-base-fee="${inferredBaseFee}"
                  data-base-value="${remainingWithCarry}"
                  data-initial-carry="${effectiveCarry}"
                  data-total-paid="${totalPaidAll}"
                  data-rem-base="${rem}"
                >${fmt(remainingWithCarry)}</strong>
              </span>
              <span data-cf-debt>Debt till now: <strong>${fmt(debtWithCarry)}</strong></span>
              <span data-cf-credit>Credit: <strong>${fmt(creditValue)}</strong></span>
            </div>
          </div>

          ${infoNote}
          ${tableSection}
        `);
        renderReconciler(mismatches, {
          studentId: ctxStudentId,
          targetYear: targetYearOverride,
          containerId: 'breakdownContent',
        });
      }

      function renderReconciler(mismatches, options = {}) {
        const containerId = options.containerId || 'breakdownContent';
        const container = document.getElementById(containerId);
        if (!container) return;
        const existing = container.querySelector('#somap-year-reconcile');
        if (existing) existing.remove();

        if (!Array.isArray(mismatches) || !mismatches.length) return;

        const target = String(options.targetYear || targetYearStr);
        const studentKey = options.studentId || studentId;

        const wrapper = document.createElement('div');
        wrapper.id = 'somap-year-reconcile';
        wrapper.className = 'mt-4 border border-amber-200 bg-amber-50 rounded p-3 text-xs';
        wrapper.innerHTML = `
          <div class="font-semibold text-amber-700 mb-2">
            Payments stored in the wrong academic year
          </div>
          <p class="text-amber-700/90 mb-2">
            Ensure each payment lives under ${target}. Fix entries below to keep ledgers accurate.
          </p>
        `;

        const list = document.createElement('div');
        list.className = 'flex flex-col gap-2';

        mismatches.forEach((entry) => {
          const amountLabel = fmt(entry.amount);
          const sourceYear = String(entry.sourceYear || target);
          const allocatedYear = entry.allocatedYear ? String(entry.allocatedYear) : '—';
          const approvalId = entry.approvalId || entry.key;
          const timestamp = Number(entry.payload?.timestamp || entry.payload?.datePaid || entry.payload?.createdAt || 0);
          const when = timestamp ? new Date(timestamp).toLocaleDateString() : '';

          const row = document.createElement('div');
          row.className = 'flex flex-wrap items-center justify-between gap-2 border border-amber-200 rounded px-2 py-1 bg-white text-amber-900';
          const left = document.createElement('div');
          left.innerHTML = `
            <div class="font-semibold">${amountLabel}</div>
            <div class="text-[11px]">
              Ref: <span class="font-semibold">${approvalId}</span>
              ${when ? `• ${when}` : ''}
              • Stored in <span class="font-semibold">${sourceYear}</span>
              • Marked for <span class="font-semibold">${allocatedYear}</span>
            </div>
          `;
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'px-2 py-1 text-xs rounded bg-amber-600 text-white hover:bg-amber-700 transition focus:outline-none focus:ring-2 focus:ring-amber-300';
          btn.textContent = `Move to ${target}`;
          btn.addEventListener('click', async () => {
            if (btn.disabled) return;
            btn.disabled = true;
            const original = btn.textContent;
            btn.textContent = 'Moving…';
            try {
              await movePaymentEntry(studentKey, target, entry);
              btn.textContent = 'Moved';
              setTimeout(() => window.location.reload(), 600);
            } catch (err) {
              console.error('Move payment failed', err);
              alert(`Failed to move payment: ${err?.message || err}`);
              btn.disabled = false;
              btn.textContent = original;
            }
          });
          row.appendChild(left);
          row.appendChild(btn);
          list.appendChild(row);
        });

        wrapper.appendChild(list);
        container.appendChild(wrapper);
      }

      async function movePaymentEntry(studentKey, targetYearValue, entry) {
        const dbInstance = typeof window.__somapGetDb === 'function' ? window.__somapGetDb() : null;
        if (!dbInstance) throw new Error('Database not ready');
        const paymentKey = entry.key;
        if (!paymentKey) throw new Error('Missing payment key');
        const targetYearString = String(targetYearValue || targetYearStr);
        const sourceYear = String(entry.sourceYear || targetYearString);
        const approvalId = entry.approvalId || paymentKey;

        const payload = { ...(entry.payload || {}) };
        payload.amount = safeNumLocal(payload.amount ?? entry.amount ?? payload.value ?? payload.paid ?? 0);
        payload.allocatedYear = targetYearString;
        payload.approvalId = approvalId;
        payload.status = payload.status || 'APPROVED';
        payload.source = payload.source || 'reconciler';
        if (!payload.timestamp) {
          const guessTs = payload.datePaid || payload.createdAt || Date.now();
          payload.timestamp = Number(guessTs) || Date.now();
        }

        const updates = {};
        updates[`financeLedgers/${targetYearString}/${studentKey}/payments/${paymentKey}`] = payload;
        updates[`financeLedgers/${studentKey}/${targetYearString}/payments/${paymentKey}`] = payload;
        if (sourceYear !== targetYearString) {
          updates[`financeLedgers/${sourceYear}/${studentKey}/payments/${paymentKey}`] = null;
          updates[`financeLedgers/${studentKey}/${sourceYear}/payments/${paymentKey}`] = null;
          updates[`financeLedgers/${studentKey}/${sourceYear}/${paymentKey}`] = null;
        }

        const approvalPayload = { ...payload };
        updates[`approvalsHistory/${targetYearString}/${approvalId}`] = approvalPayload;
        if (sourceYear !== targetYearString) {
          updates[`approvalsHistory/${sourceYear}/${approvalId}`] = null;
        }

        await dbInstance.ref().update(updates);
        if (window.__somapLedgerCache) {
          delete window.__somapLedgerCache[`${targetYearString}::${studentKey}`];
          delete window.__somapLedgerCache[`${sourceYear}::${studentKey}`];
        }
      }

      // ---- load student and render ----
      const studentId = new URL(location.href).searchParams.get('student');
      window.__STUDENT_ID__ = studentId;
      if (!studentId) { err('Error: No student ID provided in URL.'); return; }
      Promise.all([
        db.ref(`students/${studentId}`).once('value'),
        db.ref(`enrollments/${SOMAP_DEFAULT_YEAR}/${studentId}`).once('value'),
        db.ref(`enrollments/${targetYearStr}/${studentId}`).once('value'),
        db.ref(`feesStructure/${targetYearStr}`).once('value'),
        db.ref(`studentOverrides/${targetYearStr}/${studentId}`).once('value'),
        db.ref(`installmentPlans/${targetYearStr}`).once('value'),
        db.ref(`financeLedgers/${targetYearStr}/${studentId}/payments`).once('value'),
        db.ref(`financeCarryForward/${targetYearStr}/${studentId}`).once('value'),
        db.ref(`financeLedgers/${studentId}`).once('value').catch(() => ({ val: () => null })),
      ])
        .then(async ([studentSnap, anchorSnap, enrollmentSnap, classFeesSnap, overrideSnap, plansSnap, ledgerSnap, carrySnap, ledgerRootSnap]) => {
          const baseStudent = studentSnap.val();
          if (!baseStudent) { err('Student not found.'); return; }

          const anchor = anchorSnap.val() || {};
          const enrollment = enrollmentSnap.val() || {};
          const classFees = classFeesSnap.val() || {};
          const override = overrideSnap.val() || {};
          const plans = plansSnap.val() || {};
          const carry = carrySnap.val() || {};

          const ledgerRoot = (ledgerRootSnap && typeof ledgerRootSnap.val === 'function' ? ledgerRootSnap.val() : {}) || {};
          const totalPaidYear = safeNumLocal(await sumYearPaymentsFn(targetYearStr, studentId));
          const cacheKey = `${targetYearStr}::${studentId}`;
          let paymentsSource = {};
          const cachedRows = window.__somapLedgerCache?.[cacheKey]?.rows || {};
          if (cachedRows && Object.keys(cachedRows).length) {
            paymentsSource = Object.fromEntries(Object.entries(cachedRows).map(([key, row]) => [key, { ...row }]));
          }
          if (!Object.keys(paymentsSource).length) {
            paymentsSource = extractPaymentsMap(ledgerSnap.val(), targetYear);
            if (!Object.keys(paymentsSource).length) {
              try {
                const altSnap = await db.ref(`financeLedgers/${studentId}/${targetYearStr}/payments`).once('value');
                paymentsSource = extractPaymentsMap(altSnap.val(), targetYear);
              } catch (altErr) {
                console.warn('Legacy ledger path (payments) read failed', altErr?.message || altErr);
              }
            }
            if (!Object.keys(paymentsSource).length) {
              try {
                const altBucketSnap = await db.ref(`financeLedgers/${studentId}/${targetYearStr}`).once('value');
                paymentsSource = extractPaymentsMap(altBucketSnap.val(), targetYear);
              } catch (legacyBucketErr) {
                console.warn('Legacy ledger path (bucket) read failed', legacyBucketErr?.message || legacyBucketErr);
              }
            }
            if (!Object.keys(paymentsSource).length) {
              try {
                const legacyRootVal = ledgerRoot;
                paymentsSource = extractPaymentsMap(legacyRootVal, targetYear);
              } catch (legacyRootErr) {
                console.warn('Legacy ledger root read failed', legacyRootErr?.message || legacyRootErr);
              }
            }
          }

          const baseClass =
            anchor.className ||
            anchor.classLevel ||
            baseStudent.classLevel ||
            baseStudent.class ||
            enrollment.className ||
            enrollment.classLevel ||
            '';
          const deltaYears = targetYear - SOMAP_DEFAULT_YEAR;
          const classLevel = shiftClass(baseClass, deltaYears);
          const classDefaults = classFees[classLevel] || classFees[baseClass] || {};
          const resolvedPlanId = override.planId || classDefaults.defaultPlanId || null;
          const resolvedPlan = resolvedPlanId ? plans[resolvedPlanId] : null;

          const feeYearOverride = safeNumLocal(await getYearFeeFn(targetYearStr, studentId));
          const baseFeeCandidate =
            override.feePerYear ??
            classDefaults.feePerYear ??
            baseStudent.feePerYear ??
            baseStudent.feeDue ??
            baseStudent.requiredFee ??
            0;
          let baseFee = Math.max(0, Math.round(Number(baseFeeCandidate) || 0));
          if (feeYearOverride > 0) baseFee = Math.max(0, Math.round(feeYearOverride));
          const carryAmount = Math.max(0, Number(carry.amount ?? carry.balance ?? 0));
          const effectiveFee = Math.max(0, baseFee + carryAmount);

          let payments = normalizeLedgerPayments(paymentsSource, targetYear);
          if (!Object.keys(payments).length) {
            const overridePayments = normalizeLedgerPayments(coercePaymentMap(override.payments), targetYear);
            if (Object.keys(overridePayments).length) payments = overridePayments;
          }
          if (!Object.keys(payments).length) {
            const enrollmentPayments = normalizeLedgerPayments(coercePaymentMap(enrollment.payments), targetYear);
            if (Object.keys(enrollmentPayments).length) payments = enrollmentPayments;
          }
          if (!Object.keys(payments).length) {
            const basePayments = normalizeLedgerPayments(coercePaymentMap(baseStudent.payments), targetYear);
            if (Object.keys(basePayments).length) payments = basePayments;
          }

          const mismatchMap = new Map();
          const addMismatch = (entry) => {
            if (!entry || !entry.key) return;
            const approvalId = entry.approvalId || entry.key;
            entry.approvalId = approvalId;
            const mapKey = `${entry.sourceYear}::${entry.key}`;
            if (mismatchMap.has(mapKey)) return;
            mismatchMap.set(mapKey, entry);
          };

          Object.entries(paymentsSource || {}).forEach(([payKey, raw]) => {
            if (!raw) return;
            const allocated = String(raw.allocatedYear ?? raw.academicYear ?? raw.financeYear ?? targetYearStr);
            if (allocated !== targetYearStr) {
              addMismatch({
                key: payKey,
                approvalId: raw.approvalId || raw.referenceCode || payKey,
                amount: safeNumLocal(raw.amount ?? raw.value ?? raw.paid ?? raw.payment ?? 0),
                sourceYear: targetYearStr,
                allocatedYear: allocated,
                payload: { ...raw }
              });
            }
          });

          const unwrapBucket = (bucket) => {
            if (!bucket || typeof bucket !== 'object') return {};
            if (bucket.payments || bucket.entries || bucket.records) {
              return coercePaymentMap(bucket.payments || bucket.entries || bucket.records);
            }
            return coercePaymentMap(bucket);
          };

          Object.entries(ledgerRoot || {}).forEach(([yearKey, bucket]) => {
            const sourceYear = String(yearKey);
            if (!bucket) return;
            const entries = unwrapBucket(bucket);
            Object.entries(entries).forEach(([payKey, raw]) => {
              if (!raw) return;
              const allocated = String(raw.allocatedYear ?? raw.academicYear ?? raw.financeYear ?? sourceYear);
              if (allocated === targetYearStr && sourceYear !== targetYearStr) {
                addMismatch({
                  key: payKey,
                  approvalId: raw.approvalId || raw.referenceCode || payKey,
                  amount: safeNumLocal(raw.amount ?? raw.value ?? raw.paid ?? raw.payment ?? 0),
                  sourceYear,
                  allocatedYear: allocated,
                  payload: { ...raw }
                });
              }
            });
          });

          const mismatches = Array.from(mismatchMap.values()).filter(item => item.amount > 0);

          const hasYearData =
            (Object.keys(enrollment).length > 0) ||
            (Object.keys(override).length > 0) ||
            (Object.keys(payments).length > 0) ||
            (classDefaults && Object.keys(classDefaults).length > 0) ||
            carryAmount > 0;

          const planName =
            (resolvedPlan && resolvedPlan.name) ||
            override.planName ||
            override.paymentPlan ||
            enrollment.planName ||
            enrollment.paymentPlan ||
            classDefaults.defaultPlan ||
            baseStudent.paymentPlan ||
            '6-instalments';

          const prepared = {
            ...baseStudent,
            academicYear: targetYearStr,
            classLevel,
            paymentPlan: planName,
            baseFee,
            carryAmount,
            feePerYear: effectiveFee,
            payments,
            hasYearData,
            isGraduated: classLevel === 'GRADUATED',
            admissionNumber: enrollment.admissionNumber || enrollment.admissionNo || baseStudent.admissionNumber || studentId,
          };

          // Attach custom schedule or plan schedule for builder to use
          if (Array.isArray(override.customSchedule) && override.customSchedule.length) {
            prepared._customSchedule = override.customSchedule;
          } else if (resolvedPlan && Array.isArray(resolvedPlan.schedule)) {
            prepared._planSchedule = resolvedPlan.schedule; // [{label, from, to, weight}]
          }

          await render(prepared, classDefaults, override, {
            totalPaidYear,
            mismatches,
            targetYear: targetYearStr,
            studentId,
          });
        })
        .catch(e => { console.error(e); err('Error loading student data.'); });

      // resize again after fonts/images settle
      window.addEventListener('load', () => {
        const h = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
        try { window.parent.postMessage({ type:'resizeIframe', id: window.__STUDENT_ID__, height: h }, '*'); } catch {}
      });
    })();
  </script>

  <script>
  /** SoMAp v2.1 — Carry-forward overlay for January installment (prevYear >= 2025) */
  (function carryForwardIntoJanuary() {
    const START_YEAR = 2025;

    function detectTargetYear() {
      const urlYear = Number(new URL(location.href).searchParams.get('year'));
      if (!Number.isNaN(urlYear)) return urlYear;
      if (window.currentAcademicYear && Number(window.currentAcademicYear)) return Number(window.currentAcademicYear);
      try {
        const parentYear = Number(window.parent?.somapYearContext?.getSelectedYear?.());
        if (!Number.isNaN(parentYear)) return parentYear;
      } catch (_) {}
      return new Date().getFullYear();
    }

    const targetYear = detectTargetYear();
    const prevYear = targetYear - 1;
    if (!Number.isFinite(prevYear) || prevYear < START_YEAR) return;

    function parseNumberLike(value) {
      if (typeof value === 'number') return value;
      return Number(String(value || '0').replace(/[^\d\-]/g, '')) || 0;
    }

    function formatTSh(amount) { return fmt(amount); }

    async function getCarryForward(adm) {
      if (!adm) return 0;
    if (typeof window.__somap_fetchCarryForward === 'function') {
      try {
        const val = await window.__somap_fetchCarryForward(targetYear, adm);
        if (val) return Math.max(0, Number(val) || 0);
      } catch (_) {}
    }

    const storeKey = `${targetYear}::${adm}`;
      try {
        if (window.parent && window.parent.__financeCarryForwardVisual) {
          const record = window.parent.__financeCarryForwardVisual[storeKey];
          if (record && record.carry) return Math.max(0, Number(record.carry) || 0);
        }
      } catch (_) {}

      try {
        const fromSession = sessionStorage.getItem(`somap_cf_${targetYear}_${adm}`);
        if (fromSession) return Math.max(0, Number(fromSession) || 0);
      } catch (_) {}

      try {
        if (window.parent && typeof window.parent.__finance_getBalanceForYearAdmission === 'function') {
          const bal = await window.parent.__finance_getBalanceForYearAdmission(prevYear, adm);
          return Math.max(0, Number(bal) || 0);
        }
      } catch (_) {}

      if (typeof window.__finance_getBalanceForYearAdmission === 'function') {
        try {
          const bal = await window.__finance_getBalanceForYearAdmission(prevYear, adm);
          return Math.max(0, Number(bal) || 0);
        } catch (_) {}
      }

      if (window.firebase?.database) {
        try {
          const ref = window.firebase.database().ref(`finance/${prevYear}/students/${adm}`);
          const snap = await ref.get();
          if (snap.exists()) {
            const data = snap.val() || {};
            if (data.balance !== undefined) return Math.max(0, Number(data.balance) || 0);
            const feeYear = Number(String(data.feeYear || data.fee || 0).replace(/[^\d]/g, '')) || 0;
            const paid = Number(String(data.paid || 0).replace(/[^\d]/g, '')) || 0;
            return Math.max(0, feeYear - paid);
          }
        } catch (err) {
          console.warn('CarryForward January fallback fetch failed', adm, prevYear, err);
        }
      }
      return 0;
    }

    async function applyCarryForward() {
      const adm = window.__STUDENT_ID__ || new URL(location.href).searchParams.get('student') || '';
      if (!adm) return;
      const carry = await getCarryForward(adm);
      if (!carry) return;

      const tableBody = document.querySelector('#breakdownContent table tbody');
      if (!tableBody) return;
      const firstRow = tableBody.querySelector('tr');
      if (!firstRow) return;

      const cells = Array.from(firstRow.children);
      const expectedCell = cells[1];
      const remainingCell = cells[3];
      if (!expectedCell) return;

      if (!expectedCell.dataset.baseValue) {
        expectedCell.dataset.baseValue = String(parseNumberLike(expectedCell.innerText));
      }
      const baseExpected = Number(expectedCell.dataset.baseValue || 0);
      const alreadyApplied = Number(expectedCell.dataset.cfCarryApplied || 0);
      const deltaCarry = Math.max(0, carry - alreadyApplied);
      if (deltaCarry === 0 && alreadyApplied > 0) {
        // Already applied same amount; ensure summary still reflects it.
      }
      const newExpected = baseExpected + carry;

      expectedCell.dataset.cfCarryApplied = String(carry);
      expectedCell.innerHTML = `${formatTSh(newExpected)}
        <div class="text-[10px] mt-1">
          <span class="px-2 py-0.5 rounded bg-yellow-100 text-yellow-700">
            + Carry Forward (${prevYear}): ${formatTSh(carry)}
          </span>
        </div>`;
      if (remainingCell) {
        if (!remainingCell.dataset.baseValue) {
          remainingCell.dataset.baseValue = String(parseNumberLike(remainingCell.innerText));
        }
        const baseRemaining = Number(remainingCell.dataset.baseValue || 0);
        const newRemaining = baseRemaining + carry;
        remainingCell.dataset.cfCarryApplied = String(carry);
        remainingCell.innerHTML = `${formatTSh(newRemaining)}
          <div class="text-[10px] mt-1 text-slate-500">
            Includes carry-forward balance
          </div>`;
      }

      const feeStrong = document.querySelector('[data-cf-fee-year] strong');
      if (feeStrong) {
        const baseFee =
          Number(feeStrong.dataset.baseFee || feeStrong.dataset.baseValue || 0) ||
          parseNumberLike(feeStrong.textContent);
        const shownCarry = Number(feeStrong.dataset.initialCarry || feeStrong.dataset.cfCarryApplied || 0);
        if (carry > shownCarry) {
          const totalFee = baseFee + carry;
          feeStrong.textContent = formatTSh(totalFee);
          feeStrong.dataset.initialCarry = String(carry);
          feeStrong.dataset.cfCarryApplied = String(carry);
        }
      }

      const remainingStrong = document.querySelector('[data-cf-remaining] strong');
      if (remainingStrong) {
        const baseFee =
          Number(remainingStrong.dataset.baseFee || feeStrong?.dataset.baseFee || 0) ||
          parseNumberLike(remainingStrong.textContent);
        const paidTotal = Number(remainingStrong.dataset.totalPaid || 0);
        const remBase = Number(remainingStrong.dataset.remBase || 0);
        const shownCarry = Number(remainingStrong.dataset.initialCarry || remainingStrong.dataset.cfCarryApplied || 0);
        if (carry > shownCarry) {
          const recomputed = Math.max(remBase, Math.max(0, (baseFee + carry) - paidTotal));
          remainingStrong.textContent = formatTSh(recomputed);
          remainingStrong.dataset.initialCarry = String(carry);
          remainingStrong.dataset.cfCarryApplied = String(carry);
        }
      }

      const carrySlot = document.querySelector('[data-cf-carry-slot]');
      if (carrySlot) {
        carrySlot.innerHTML = `<span class="px-2 py-0.5 rounded bg-yellow-100 text-yellow-700">Carry Forward (${prevYear}): ${formatTSh(carry)}</span>`;
      }
    }

    function startObserver() {
      const container = document.getElementById('breakdownContent');
      if (!container) return;
      const attempt = () => { applyCarryForward(); };
      if (container.querySelector('table tbody tr')) {
        attempt();
        return;
      }
      const observer = new MutationObserver(() => {
        if (container.querySelector('table tbody tr')) {
          observer.disconnect();
          attempt();
        }
      });
      observer.observe(container, { childList: true, subtree: true });
      setTimeout(() => observer.disconnect(), 12000);
    }

    if (document.readyState === 'complete' || document.readyState === 'interactive') {
      startObserver();
    } else {
      document.addEventListener('DOMContentLoaded', startObserver);
    }
  })();
  </script>
</body>
</html>
