<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SoMAp — Academic & Exams Module (Fixed)</title>

  <!-- Tailwind CDN -->
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    body { font-family: Inter, ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; }
    .pill { padding:4px 8px; border-radius:8px; font-weight:600; }
    .muted { color:#6b7280; }
    .status-pill { padding:2px 8px; border-radius:999px; font-size: 11px; font-weight:600; }
    .status-paid { background:#dcfce7; color:#166534; }
    .status-partial { background:#fef9c3; color:#854d0e; }
    .status-overdue { background:#fee2e2; color:#991b1b; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.0/jspdf.plugin.autotable.min.js"></script>
</head>
<body class="p-6">
  <div class="max-w-6xl mx-auto">
    <header class="flex items-center justify-between mb-6">
      <h1 class="text-2xl font-semibold text-indigo-700">SoMAp — Academic & Exams Module</h1>
      <div class="space-x-2">
        <button id="btnLoad" class="px-3 py-2 rounded bg-indigo-600 text-white">Load</button>
      </div>
    </header>

    <!-- Main UI skeleton (kept intact from existing file) -->

  </div>

<script>
  // Existing helper: getDB - initialize firebase DB from included firebase config script
  function getDB(){
    if(window.db) return window.db;
    if(window.firebase && window.firebase.apps && window.firebase.apps.length){
      const cfg = window.firebaseConfig || window.__fbConfig || null;
      if(!window.firebase.apps.length) return null;
      if(!window.db) window.db = firebase.database();
      return window.db;
    }
    console.error('DB not found.');
    alert('DB not ready. Ensure firebase.js initializes window.db.');
  }
  function fmt(n) {
    n = Number(n) || 0;
    return n.toLocaleString();
  }

  /* ---------- Robust student loader (attendance style) ---------- */
  async function fetchStudents(className, stream){
    const db = getDB();
    if(!db) return [];
    const tryPaths = ['students','Students','StudentsList','StudentList','studentList','studentlist','attendance','school','schoolerp'];
    for(const p of tryPaths){
      try{
        const snap = await db.ref(p).get();
        if(snap && snap.exists && snap.exists()){
          const data = snap.val();
          // If data looks like attendance map (nested months/classes) -> attempt to drill
          // But for simplicity, convert object keys to student objects
          const arr = [];
          if(Array.isArray(data)){
            data.forEach((item, idx)=> {
              if(item) {
                const adm = item.adm || item.admissionNumber || item.admNo || ('A'+idx);
                const s = item || {};
                arr.push(normalizeStudentRecord(adm, s));
              }
            });
          } else if(typeof data === 'object' && data){
            Object.keys(data).forEach(k=>{
              const item = data[k];
              if(item && typeof item === 'object'){
                const adm = item.adm || item.admissionNumber || item.admNo || (item.admNo || k);
                arr.push(normalizeStudentRecord(adm, item));
              }
            });
          }
          // filter by class/stream if provided
          const filtered = arr.filter(x=>{
            const classMatches = !className || String(x.class) === String(className);
            const streamMatches = !stream || !x.stream || String(x.stream) === String(stream);
            return classMatches && streamMatches;
          });
          filtered.sort((a,b)=> (a.name || '').localeCompare(b.name || ''));
          if(filtered.length) return filtered;
        }
      }catch(err){
        // ignore and continue
        console.warn('fetch path failed', p, err);
      }
    }
    return [];
  }

  // normalize student record - now enhanced to compute finances using the same logic as finance.html
  function normalizeStudentRecord(admKey, s){
    const name = [s.firstName, s.middleName, s.lastName].filter(Boolean).join(' ').trim() || s.name || s.fullName || ('Student ' + admKey);
    const sClass = s.class || s.currentClass || s.level || s.className || s.grade || s.classLevel || '';
    const sStream = s.stream || s.streamName || s.section || '';
    let feeDue = Number(s.totalFee || s.feePerYear || s.feeDue || s.required || s.debt || 0);
    let feePaid = Number(s.paid || s.feePaid || s.totalPaid || s.paidAmount || s.credit || 0);
    let balance = Number(s.balance || Math.max(0, feeDue - feePaid) || 0);
    // if payments object or schedule exists, prefer computed financials (align with finance module)
    try{
      if(s.payments || s.paymentSchedule || s.paymentPlan || s.payment){
        const fin = finance_computeStudentFinancials(s);
        feeDue = Number(fin.feePerYear || feeDue);
        feePaid = Number(fin.paidAmount || feePaid);
        balance = Number(fin.balance || balance);
        // attach computed financial summary to meta for debugging/UI use
        s._financialComputed = fin;
      }
    }catch(e){
      console.error('Error computing finance for student', e);
    }
    return { adm: admKey, name, class: sClass, stream: sStream, feeDue, feePaid, balance, meta: s };
  }

  /* ---------- Attendance + fees + scores fetchers ---------- */
  async function fetchAttendance(year, month, className){
    const db = getDB();
    if(!db) return {};
    const refPath = `/attendance/${year}/${month}/${className}`;
    try{
      const snap = await db.ref(refPath).get();
      const out = {};
      if(snap && snap.exists && snap.exists()){
        const val = snap.val();
        Object.keys(val).forEach(adm=>{
          const a = val[adm] || {};
          out[adm] = a;
        });
      }
      return out;
    }catch(err){
      console.error('fetchAttendance error', err);
      return {};
    }
  }

  /* ---------- Summary helpers ---------- */
  function summarizeStudents(arr){
    const summary = { attendance: {}, fees: {} };
    let sumP=0, sumA=0, sumD=0;
    let feeReq=0, feePaid=0, feeBal=0;
    arr.forEach(st=>{
      const f = st.meta || {};
      sumP += f.present || 0; sumA += f.absent || 0; sumD += (f.days || 0);
      feeReq += f.required||0; feePaid += f.paid||0; feeBal += f.balance||0;
    });
    summary.attendance = { present: sumP, absent: sumA, days: sumD };
    summary.fees = { required: feeReq, paid: feePaid, balance: feeBal };
    return summary;
  }

  /* ---------- Finance helpers (namespaced) ---------- */

  // The following helper functions are adapted from the finance module and namespaced
  function finance_fmt(n) { n = Number(n) || 0; return n.toLocaleString(); }
  function finance_clamp(n) { return Math.max(0, Math.round(Number(n) || 0)); }
  function finance_todayYMD() { const d = new Date(); return { y: d.getFullYear(), m: d.getMonth() + 1, d: d.getDate() }; }
  function finance_dateFromYMD(y, m, d) { return new Date(y, m - 1, d).getTime(); }
  function finance_isPast(ts) { return Date.now() > ts; }
  function finance_apportion(total, weights) {
    weights = (weights || []).map(w=>Number(w)||0);
    const s = weights.reduce((a,b)=>a+b,0) || 1;
    const raw = weights.map(w => Math.floor(total * (w/s)));
    let sum = raw.reduce((a,b)=>a+b,0);
    const amounts = raw.slice();
    let rem = Math.round(total - sum);
    if(rem>0){
      // distribute remainder to largest weights
      const idxs = weights.map((w,i)=>[w,i]).sort((a,b)=>b[0]-a[0]).map(x=>x[1]);
      for(let i=0;i<rem;i++) amounts[idxs[i%idxs.length]]++;
    }
    return amounts;
  }

  const finance_installmentConfigs = {
    lower: {
      type: '6',
      weights: [44, 13, 12, 22, 22, 16],
      labels: ['Inst 1', 'Inst 2', 'Inst 3', 'Inst 4', 'Inst 5', 'Inst 6'],
      windows: [
        { from: [12, 1], to: [1, 10] },
        { from: [3, 1], to: [3, 15] },
        { from: [4, 1], to: [4, 15] },
        { from: [5, 1], to: [5, 15] },
        { from: [7, 1], to: [7, 15] },
        { from: [9, 1], to: [9, 15] },
      ]
    },
    class4_7: {
      type: '6',
      weights: [44, 8, 12, 12, 16, 8],
      labels: ['Inst 1', 'Inst 2', 'Inst 3', 'Inst 4', 'Inst 5', 'Inst 6'],
      windows: [
        { from: [12, 1], to: [1, 10] },
        { from: [2, 1], to: [2, 10] },
        { from: [3, 1], to: [3, 15] },
        { from: [4, 1], to: [4, 15] },
        { from: [6, 1], to: [6, 15] },
        { from: [8, 1], to: [8, 15] },
      ]
    },
    monthly: {
      type: 'monthly',
      weights: [2, 1, 1, 1, 1, 1, 2, 1, 1, 1],
      labels: ['Jan (2 months)', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul (2 months)', 'Aug', 'Sep', 'Oct'],
      windows: [
        { from: [1, 1], to: [1, 31] },
        { from: [2, 1], to: [2, 28] },
        { from: [3, 1], to: [3, 31] },
        { from: [4, 1], to: [4, 30] },
        { from: [5, 1], to: [5, 31] },
        { from: [6, 1], to: [6, 30] },
        { from: [7, 1], to: [7, 31] },
        { from: [8, 1], to: [8, 31] },
        { from: [9, 1], to: [9, 30] },
        { from: [10, 1], to: [10, 31] }
      ]
    },
    full: {
      type: 'full',
      weights: [100],
      labels: ['Full'],
      windows: [[{ from: [1,1], to: [12,31] }]]
    }
  };

  function finance_getConfig(student){
    // pick rules by payment plan, class or explicit config
    const plan = (student.paymentPlan || student.paymentType || student.payment || '').toString().toLowerCase();
    const c = (student.installmentConfig || student.paymentConfig || '').toString().toLowerCase();
    const cls = (student.class || student.className || '').toString().toLowerCase();
    if(c && finance_installmentConfigs[c]) return finance_installmentConfigs[c];
    if(plan.includes('monthly')) return finance_installmentConfigs.monthly;
    if(plan.includes('inst') || plan.includes('6')) return finance_installmentConfigs.class4_7;
    if(cls.includes('class 5')|| cls.includes('class 6')) return finance_installmentConfigs.class4_7;
    return finance_installmentConfigs.lower;
  }

  function finance_buildSchedule(student) {
    const config = finance_getConfig(student);
    const { y } = finance_todayYMD();
    let feeBase = Number(student.feePerYear) || 0;
    const discount = Number(config.discount) || 1;
    feeBase = Math.round(feeBase * discount);
    const weights = config.weights;
    const amounts = finance_apportion(feeBase, weights);
    const sc = [];
    config.labels.forEach((label, i) => {
      let fromY = y, toY = y;
      const fromM = config.windows[i].from[0], fromD = config.windows[i].from[1];
      const toM = config.windows[i].to[0], toD = config.windows[i].to[1];
      if (fromM === 12) fromY = y - 1;
      if (toM === 12) toY = y - 1;
      const fromTS = finance_dateFromYMD(fromY, fromM, fromD);
      const toTS = finance_dateFromYMD(toY, toM, toD);
      sc.push({ label, amount: amounts[i] || 0, fromTS, toTS, paidAllocated: 0, status: 'Pending', idx: i });
    });
    return { items: sc, periodLabelNow: config.labels[0] || '—', expectedToDate: 0 };
  }

  function finance_allocatePayments(student, schedule) {
    const payList = [];
    if (student.payments) {
      Object.values(student.payments).forEach(p => {
        payList.push({ amount: finance_clamp(p.amount), ts: Number(p.timestamp) || 0 });
      });
    }
    payList.sort((a, b) => a.ts - b.ts);
    let pot = payList.reduce((s, p) => s + p.amount, 0);
    const totalPaid = pot;
    let prevDebt = finance_clamp(student.previousDebt || student.debt);
    let toPrev = Math.min(prevDebt, pot);
    prevDebt -= toPrev;
    pot -= toPrev;
    // allocate to schedule items sequentially
    for (const it of schedule.items) {
      const need = it.amount;
      const use = Math.min(need, pot);
      it.paidAllocated = use;
      if (use >= need) {
        it.status = 'Cleared';
      } else if (use > 0) {
        it.status = 'Partially Paid';
      } else {
        it.status = 'Pending';
      }
      pot -= use;
    }
    const credit = Math.max(0, pot);
    const now = Date.now();
    let debtTillNow = 0;
    for (const it of schedule.items) {
      const a = it.paidAllocated;
      const need = it.amount;
      if (a >= need) {
        it.status = 'Cleared';
      } else {
        if (finance_isPast(it.toTS)) {
          it.status = a > 0 ? 'Partially Paid (Overdue)' : 'Overdue';
        } else {
          it.status = a > 0 ? 'Partially Paid' : 'Pending';
        }
        debtTillNow += Math.max(0, need - a);
      }
    }
    return { totalPaid, prevDebtAfter: prevDebt, scheduleItems: schedule.items, credit, debtTillNow };
  }

  function finance_computeStudentFinancials(student){
    const feePerYear = Number(student.feePerYear) || 0;
    const previousDebt = finance_clamp(student.previousDebt || student.debt);
    const schedule = finance_buildSchedule(student);
    const alloc = finance_allocatePayments(student, schedule);
    const paidAfterPrev = Math.max(0, alloc.totalPaid - (previousDebt - alloc.prevDebtAfter));
    const yearBalance = Math.max(0, feePerYear - paidAfterPrev);
    return {
      feePerYear,
      previousDebt,
      paidAmount: alloc.totalPaid,
      balance: yearBalance,
      periodDebtLabel: schedule.periodLabelNow || '—',
      periodDebtValue: alloc.debtTillNow,
      credit: alloc.credit,
      scheduleItems: alloc.scheduleItems
    };
  }

  /* ---------- Load sequence (main entry) ---------- */
  (function ensureLoadButton(){
    const btn = document.getElementById('btnLoad');
    if(btn){
      btn.addEventListener('click', async ()=>{
        btn.disabled = true; btn.innerText = 'Loading...';
        try{
          const className = prompt('Enter class to load (or leave empty for all):');
          const stream = prompt('Enter stream (optional):');
          const students = await fetchStudents(className, stream);
          console.log('Loaded students', students.length);
          // Render a simple table (kept minimal so existing UI remains)
          renderStudentsTable(students);
        }catch(err){
          console.error(err);
          alert('Error loading students: '+err.message);
        }
        btn.disabled = false; btn.innerText = 'Load';
      });
    }
  })();

  function renderStudentsTable(list){
    const container = document.querySelector('.max-w-6xl');
    let html = '<div class="mt-6 overflow-x-auto bg-white p-4 rounded shadow">';
    html += '<table class="w-full text-sm"><thead><tr class="text-left"><th>#</th><th>Adm</th><th>Name</th><th>Class</th><th>Fee Due</th><th>Paid</th><th>Balance</th></tr></thead><tbody>';
    list.forEach((s, idx)=>{
      html += `<tr class="border-t"><td class="py-2">${idx+1}</td><td class="py-2">${s.adm}</td><td class="py-2">${s.name}</td><td class="py-2">${s.class||''}</td><td class="py-2">${fmt(s.feeDue)}</td><td class="py-2">${fmt(s.feePaid)}</td><td class="py-2">${fmt(s.balance)}</td></tr>`;
    });
    html += '</tbody></table></div>';
    // replace existing content area
    const existing = document.querySelector('.max-w-6xl');
    existing.innerHTML = '<header class="flex items-center justify-between mb-6"><h1 class="text-2xl font-semibold text-indigo-700">SoMAp — Academic & Exams Module (Preview)</h1></header>' + html;
  }

</script>
</body>
</html>